var RoadmapConstants = require('./RoadmapConstants'),
    Proxy = require('roadmapper/data/Proxy'),
    JamaItemProxy = require('roadmapper/data/JamaItemProxy'),
    _ = require('lodash'),
    when = require('when');

//Proxy actions should return promises that then resolve and always be async
var RoadmapActions = {
    saveRoadmap: function(payload) {
        Proxy.saveRoadmap(payload.id, payload.roadmap);
        // this.dispatch(RoadmapConstants.ROADMAP_SAVE_ROADMAP, payload);
    },
    loadItemsForRoadmap: function(payload) {
        JamaItemProxy.getChildren(payload.jamaApiId, _.bind(function(err, res) {
            payload.items = res.body.data;
            this.dispatch(RoadmapConstants.ROADMAP_ADD_ITEMS_TO_ROADMAP, payload);
        }, this))
    },
    createRoadmap: function(payload) {
        Proxy.createRoadmap(payload);
        payload.items = [];
        this.dispatch(RoadmapConstants.ROADMAP_CREATE_ROADMAP, payload);
    },
    deleteRoadmap: function(payload) {
        Proxy.deleteRoadmap(payload.roadmapId);
        this.dispatch(RoadmapConstants.ROADMAP_DELETE_ROADMAP, payload);
    },
    refreshItems: function(payload) {

        var promises = _.map(payload.items, function(item) {
            var defer = when.defer();
            JamaItemProxy.getItem(item.id, _.bind(function(err, res) {
                var updateItem = {
                    item: res.body.data,
                    roadmapId: payload.roadmapId
                };
                defer.resolve(updateItem);
            }, this));
            return defer.promise;
        }, this)

        when.all(promises).then(_.bind(function(items) {
            this.dispatch(RoadmapConstants.ROADMAP_UPDATE_ROADMAP_ITEM, items);
        }, this));
    },
    updateJamaItem: function(payload) {
        JamaItemProxy.updateItem(payload.id, payload.item, _.bind(function(err, res) {
            this.dispatch(RoadmapConstants.ROADMAP_UPDATE_JAMA_ITEM, payload);
        }, this));
    }
}

module.exports = RoadmapActions;